---
title: A framework for coding interviews
published: true
listed: true
date: '12/22/2021'
lastUpdateDate: '07/24/2022'
description: Walk through of a framework I've used in technical coding interviews
tags: technical interviews,musing
---

Since last year, I have been interviewing a lot with different companies - FANNGs companies and startups. All of the interviews had some portion of data structure & algorithms type of questions (a.k.a leetcode questions with traditional memory/CPU trade-offs) as part of the interview processes: in my experience, FANNGs companies tend to be algorithms-heavy while startups e.g. Stripe focus more on practical skills such as debugging.

> YMMV some companies or teams interview loops don't evaluate role fit and some do. That means you could get web-oriented interview loops for frontend web candidates sometimes. Try talk to your recruiter about it beforehand.

I ended up getting offers from Meta (f.k.a Facebook), Microsoft, Asana, Twitch, Coinbase etc. so I guess the way I approached the coding interviews worked, to some extent, at least for me.


## Ask clarifying questions before coding

Take a moment to internalize the problem and repeat the goal of the challenge back to the interviewer(s). This will either get you confirmation on your way forward or they'll help you correct course. After that, you need to ask a series of clarifying questions:

### 1. Define input and output
1. How is the input stored? E.g. If we are given a collection of words, is it a list of strings or a Trie?
    1. What kind of values are there? 
        - Are there negative numbers? Floating points? 
        - Will there be empty inputs? Are there duplicates within the input?
    2. Can I always assume valid input? 
        - If we need to find the kth largest element in the array, can `k` be negative number, or can it be bigger than the array size?
2. How is the output defined? i.e. What do we need to return 
        - Are we returning index or actual items? 
        - What if there are multiple equally qualified outputs?


### 2. Check your assumptions about the size/range/scale of the data

1. How big is the size of the input? 
2. How big is the range of the values? 
    - If we are dealing with multiplication here, do we need to worry about integer overflow? 

### 3. Ask requirements for runtime and space complexity

This is pretty self-explanatory and they probably want an optimal solution but it is still worth asking. 

For example, if the size of the input is small enough, a `O(n^2)` solution might be more desirable than a `O(nlogn)` solution if `n` is [small enough.](https://stackoverflow.com/questions/23329234/which-is-better-on-log-n-or-on2)

### 4. Check assumptions of the environment the code is running on

1. What kind of environment is this algorithm expected to run in? - single or multi-threaded environment?
2. Can I destroy/mutate the original array/graph/data structure?
3. Can I assume I can use new syntax/language features in whatever the language I am using? In the context of JavaScript, I would ask if we have transpiling and polyfills available for older browsers.


## Walk through your solution

After asking these questions, from there, start writing **comments** in the editor and outlining step by step what it is what you'll be doing. This gives you a blueprint to follow, and it also shows them how you think, how you communicate, and it lets them give you feedback before you even start, which hopefully they do.

Finally, it's time to solve the challenge and start coding.

## During coding
You want to give the interviewers as many positive signals as possible. 

1. See if you can divide the problems into subproblems
2. Separate your code into logical units
3. Discuss tradeoffs - consider pros and cons and alternatives
    1. are you favouring runtime complexity over space complexity by throwing a hashmap at the question?
    2. are you aware of a potential large memory footprint caused by a recursive approach without tail call optimization?
4. come up with your own test cases and run it through your code. 
5. explain the time and space complexity



## Some meta-techniques for improving coding skills

- Get feedback from an expert coach. If not, this could be from a layperson, although personally I haven’t never felt the need to conduct a mock interview with a friend...
- Or get feedback from yourself by recording yourself solving those questions. In modern software development, we never operate a complex software system without metrics or tracing, but it's normal to operate yourself without metrics or tracing, even though you're much more complex and harder to understand than the software you work on. By viewing a replay yourselve, you might improve a lot things that otherwise are completely non-obvious to you.
- Learn to talk while you code. Just practice it like any other skill. Turn a mundane talk into a captivating high-wire act. Instead of you proving yourself, you talk like you teach others how to do the thing you are doing and people are attracted to confidence.

## Random thoughts on coding interviews

Whether or not these coding interviews are good tools or meaningful ways to assess software engineer candidates across multiple dimensions is a contentious topic. While there are people geniuely believe that they can get meaningful signals from these leetcode questions, I found there are generally two camps of people who also are in favor of algorithm-style coding interviews

1. “I’m good at this style of question and I’m smart, therefore this style of question tells you how smart someone is”
2. “I used to suck at these and after spending countless hours grinding leetcode, now I know how to play the game and you need to be in practice at the game too if you want to join my company”

I think I can at least understand the former line of reasoning, even if I disagree. What seems so funny to me is the latter. Maybe they do get a lot of value out of grinding leetcode. I am not sure.

I personally think this algorithm type of programming problems is a fine way to assess many things - problem solving skills, communication skills, coding skills etc. They can be streamlined and standardized and therefore they are scalable. They are useful for eliminating false positives at the cost of having a few false negatives.

But I don’t think high performance on coding interview has a very positively correlation with high performance on the actual job. It’s really difficult to measure programmer effectiveness in anything resembling an objective manner, so I don’t know any better solutions either.
